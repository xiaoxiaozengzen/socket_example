# Overview

# 三次握手

![三次握手](../doc/tcp-shakes-hands-three-times.png)

* 一次握手:客户端发送带有 SYN（SEQ=x） 标志的数据包 -> 服务端，然后客户端进入 SYN_SEND 状态，等待服务端的确认；
* 二次握手:服务端发送带有 SYN+ACK(SEQ=y,ACK=x+1) 标志的数据包 –> 客户端,然后服务端进入 SYN_RECV 状态；
* 三次握手:客户端发送带有 ACK(ACK=y+1) 标志的数据包 –> 服务端，然后客户端和服务端都进入ESTABLISHED 状态，完成 TCP 三次握手。

一下是wireshark抓包得到的数据：
![shake](../doc/shake.jpeg)

## 半连接和全连接

tcp三次握手过程中，linux内核会维护两个队列来管理：
* 1. 半连接队列：当服务端收到SYN包文，此时双方还未建立连接，内核会把半连接的状态的连接放到半连接队列中
* 2. 全连接队列：
  * 当服务端收到客户端对 ACK 响应时，意味着三次握手成功完成，服务端会将该连接从半连接队列移动到全连接队列。
  * 如果未收到客户端的 ACK 响应会进行重传，重传的等待时间通常是指数增长的。如果重传次数超过系统规定的最大重传次数，系统将从半连接队列中删除该连接信息。

## 必要性

三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。
* 1. 第一次握手：
  * Client 什么都不能确认；
  * Server 确认了对方发送正常，自己接收正常
* 2. 第二次握手：
  * Client 确认了：自己发送、接收正常，对方发送、接收正常；
  * Server 确认了：对方发送正常，自己接收正常
* 3. 第三次握手：
  * Client 确认了：自己发送、接收正常，对方发送、接收正常；
  * Server 确认了：自己发送、接收正常，对方发送、接收正常

# 四次挥手

![四次挥手](../doc/tcp-waves-four-times.png)

断开一个 TCP 连接则需要“四次挥手”，缺一不可：
* 1. 第一次挥手：客户端发送一个 FIN（SEQ=x） 标志的数据包->服务端，用来关闭客户端到服务端的数据传送。然后客户端进入 FIN-WAIT-1 状态。
* 2. 第二次挥手：服务端收到这个 FIN（SEQ=X） 标志的数据包，它发送一个 ACK （ACK=x+1）标志的数据包->客户端 。然后服务端进入 CLOSE-WAIT 状态，客户端进入 FIN-WAIT-2 状态。
* 3. 第三次挥手：服务端发送一个 FIN (SEQ=y)标志的数据包->客户端，请求关闭连接，然后服务端进入 LAST-ACK 状态。
* 4. 第四次挥手：客户端发送 ACK (ACK=y+1)标志的数据包->服务端，然后客户端进入TIME-WAIT状态，服务端在收到 ACK (ACK=y+1)标志的数据包后进入CLOSE 状态。此时如果客户端等待 2MSL 后依然没有收到回复，就证明服务端已正常关闭，随后客户端也可以关闭连接了。

只要四次挥手没有结束，客户端和服务端就可以继续传输数据！这是wirkshark的抓包数据：
![wave](../doc/wave.jpeg)

**注意**
wireshark中四次挥手显示三次：
这是因为服务端的两次回复被放到一个包了

## 为什么四次挥手

TCP 是全双工通信，可以双向传输数据。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。

## 等待2MSL

第四次挥手时，客户端发送给服务端的 ACK 有可能丢失，如果服务端因为某些原因而没有收到 ACK 的话，服务端就会重发 FIN，如果客户端在 2*MSL 的时间内收到了 FIN，就会重新发送 ACK 并再次等待 2MSL，防止 Server 没有收到 ACK 而不断重发 FIN。

MSL(Maximum Segment Lifetime) : 一个片段在网络中最大的存活时间，2MSL 就是一个发送和一个回复所需的最大时间。如果直到 2MSL，Client 都没有再次收到 FIN，那么 Client 推断 ACK 已经被成功接收，则结束 TCP 连接。

